<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>STL Reader</title>
	<style>
		body { 
			margin: 0;
			padding: 0;
			border: 0;
			font-family: sans-serif;
			font-size: 15px;
		}

		div.sidebar { 
			position: fixed;
			top: 0;
			bottom: 0;
			left: 0;
			width: 200px;
			background: lightgrey;
			z-index: 1;
			min-width: 200px;
		}

		div.sidebar input[type="file"] { 
			float: left;
			-webkit-box-sizing: border-box;
			-moz-box-sizing: border-box;
			box-sizing: border-box;
			width: 100%;
			border-bottom: 1px solid grey;
			padding: 3px;
		}

		div.sidebar div {
			-webkit-box-sizing: border-box;
			-moz-box-sizing: border-box;
			box-sizing: border-box;
			width: 100%;
			float: left;
			padding: 5px;
		}

		div.sidebar div.divider {
			width: 100%;
			height: 1px;
			padding: 0;
			background: grey;
		}

		div.sidebar div.expander {
			position: fixed;
			left: 200px;
			height: 100%;
			width: 5px;
			background: lightgrey;
			border-right: 1px solid grey;
			border-left: 2px solid grey;
			padding: 0;
			cursor: col-resize;
		}

		canvas {
			position: fixed;
			top: 0;
			left: 200px;
		}
	</style>
</head>

<script src="jquery-1.11.1.min.js"></script>
<script src="three.min.js"></script>
<script src="OrbitControls.js"></script>

<body>
	<div class="sidebar">
		<div class="expander"></div>
		<input type="file" id="stl_input" onchange="handleStlFile(this.files)">
		<div class="triangle-face-count">Triangle Faces: --</div>
		<div class="triangle-vertex-count">Triangle Vertices: --</div>
		<div class="triangle-line-count">Triangle Lines: --</div>
		<div class="divider"></div>
		<div class="regular-face-count">Regular Faces: --</div>
		<div class="regular-vertex-count">Regular Vertices: --</div>
		<div class="regular-line-count">Regular Lines: --</div>
	</div>
</body>

<script>
// setting up three.js to render stl object
var scene = new THREE.Scene();
var camera = new THREE.PerspectiveCamera( 75, (window.innerWidth - 200) / window.innerHeight, 0.1, 1000 );

var renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize( window.innerWidth - 200, window.innerHeight );
document.body.appendChild( renderer.domElement );

camera.position.set( -40, -40, 10 );

cameraControls = new THREE.OrbitControls(camera, renderer.domElement);
cameraControls.target.set( 0, 0, 0);
cameraControls.update();

// maybe use lighting later -> need to use lambert or phong materials instead of basic
// var ambientLight = new THREE.AmbientLight(0x330000);
//  scene.add(ambientLight);

// var pointLight = new THREE.PointLight(0xffffff);
// pointLight.position.set( 100, 100, 100 );
// scene.add( pointLight );

// var directionalLight = new THREE.DirectionalLight(0xffffff);
//  directionalLight.position.set(1, 1, 1).normalize();
//  scene.add(directionalLight);

// three.js rendering loop
function render() {
	renderer.render( scene, camera );
	requestAnimationFrame( render );
	cameraControls.update();
}

render();


// this function handles the file stl file input using filereader
function handleStlFile(files) {
	file = files[0]
	if (file) {
		// check if file is stl file
		var fileName = file.name;
		if (fileName.substring(fileName.length - 4,fileName.length) === ".stl") {
			// read as text -> if file starts with solid, it is ascii format otherwise it is binary
			var reader = new FileReader();
			reader.readAsText(file, "UTF-8");
			
			reader.onload = function (evt) {
				// remove previous solid if any
				removePreviousSolid();
				if (evt.target.result.substr(0,5) === "solid") {
					asciiHandle(evt);
				} else {
					binaryHandle(evt);
				}
			}
			
			reader.onerror = function (evt) {
				console.log("error reading file")
			}
		} else {
			console.log("file is not an stl file")
		}
	}
}

// handling ascii format stl file
var asciiHandle = function (evt) {
	// capture vertices and normals with regex
	var vertRegex = /(vertex\s-?[\d\.]+\s-?[\d\.]+\s-?[\d\.]+)/g;
	var vertMatches = evt.target.result.match(vertRegex);

	var normRegex = /(facet\snormal\s-?[\d\.]+\s-?[\d\.]+\s-?[\d\.]+)/g;
	var normMatches = evt.target.result.match(normRegex);

	// initialize three.js geometry to put all faces in
	var geometry = new THREE.Geometry();
	
	// Make each face a different material so color of face can be changed when clicked.
	// This makes larger solids render very slowly so should try another way of doing this.
	var geomMats = new Array(vertMatches.length);

	// lines is an object that is used like a hash to save which line connects which two faces.
	// lines[vertex 1, vertex 2] = [face 1, face 2]
	var lines = {}
	
	// vertices is an object that is used like a hash, saving normals of faces including the vertex.
	// Up to two normals is saved since if there is more than one normal, it is a regular vertex.
	// vertices[vertex index] = [normal, normal]
	var vertices = {}
	
	var addFaceToLine = function(lines, line, currFace) {
		if (lines[line]) {
			lines[line].push(currFace);
		} else {
			lines[line] = [currFace];
		}
	};
	
	// function that populates the lines object
	var lineHandle = function(lines, currFace, v1Index, v2Index, v3Index) {
		var line = [v1Index,v2Index].sort();
		addFaceToLine(lines, line, currFace);

		var line = [v2Index,v3Index].sort();
		addFaceToLine(lines, line, currFace);

		var line = [v1Index,v3Index].sort();
		addFaceToLine(lines, line, currFace);
	};
	
	// function that populates the vertices object
	var addNormalToVertices = function (vertexIndex, currFaceNormal) {
		if (vertices[vertexIndex]) {
			if (vertices[vertexIndex].length < 2) {
				if (!isSameVectorOrVertex(vertices[vertexIndex][0], currFaceNormal)) {
					vertices[vertexIndex].push(currFaceNormal);
				}
			}
		} else {
			vertices[vertexIndex] = [currFaceNormal];
		}
	}
	
	// Function that checks if vertex is already in the geometry. If not, adds vertex to the geometry.
	// Returns the three.js vertex object and it's index in the geometry vertex array
	var vertexHandle = function(split, geometry) {
		var vertIndex = -1;
		var vert = new THREE.Vector3(parseFloat(split[1]),parseFloat(split[2]),parseFloat(split[3]));
		
		geometry.vertices.forEach(function(vertex, index) {
			if (isSameVectorOrVertex(vert, vertex)) {
				vertIndex = index + 1;
				return false;
			}
		});

		if (vertIndex === -1) {
			vertIndex = geometry.vertices.push(vert);
		}

		return [vert, vertIndex];
	};
	
	// stl vertex handling
	for (var i = 0; i < vertMatches.length; i++) {
		geomMats[i] = new THREE.MeshBasicMaterial({color: 0xff0000, opacity: 0.5, transparent: true});
		split = vertMatches[i].split(" ")
		
		// since there are only triangles, on every third vertex a face object is made
		var v1, v2, v3, v1Index, v2Index, v3Index;
		if (i % 3 == 0) {
			var result = vertexHandle(split, geometry);
			v1 = result[0];
			v1Index = result[1];
		} else if (i % 3 == 1) {
			var result = vertexHandle(split, geometry);
			v2 = result[0];
			v2Index = result[1];
		} else if (i % 3 == 2) {
			var result = vertexHandle(split, geometry);
			v3 = result[0];
			v3Index = result[1];

			// stl normal handling
			normSplit = normMatches[Math.floor(i/3)].split(" ");
			normal = new THREE.Vector3(parseFloat(normSplit[2]),parseFloat(normSplit[3]),parseFloat(normSplit[4]));
			
			// making three.js face object from last three vertices and adding to the geometry
      var face2 = new THREE.Face3(v1Index - 1, v2Index - 1, v3Index - 1, normal);
      face2.materialIndex = i;
			var currFace = geometry.faces.push(face2);
			currFace -= 1;
			
			// making face on the back side makes the solid look better but worse performance and some bugs...
      // var face1 = new THREE.Face3(geometry.vertices.length-2,geometry.vertices.length-3,geometry.vertices.length-1);
      // face1.materialIndex = i;
			// geometry.faces.push(face1);

			// populate the line object
			lineHandle(lines, currFace, v1Index, v2Index, v3Index);
			
			// populate the vertices object
			var currFaceNormal = geometry.faces[geometry.faces.length - 1].normal;
			addNormalToVertices(v1Index, currFaceNormal);
			addNormalToVertices(v2Index, currFaceNormal);
			addNormalToVertices(v3Index, currFaceNormal);
		}
	}

	// adding two versions of the geometry to the scene: wireframe and basic material
	var wireframe = new THREE.MeshBasicMaterial({color: 0xffff00, wireframe: true});
	var triangle = new THREE.Mesh(geometry, new THREE.MeshFaceMaterial(geomMats));
	var triangle2 = new THREE.Mesh(geometry, wireframe);

	scene.add(triangle)
	scene.add(triangle2)
	
	// Filling statistics in sidebar and calculating regular faces, vertices, and lines
	postProcess(geometry, lines, vertices)
}


// handling binary format stl file
// the code for this part was copied from:
// http://tonylukasavage.com/blog/2013/04/10/web-based-stl-viewing-three-dot-js/
// and modified
var binaryHandle = function (evt) {
	var reader = new FileReader();
	reader.readAsArrayBuffer(file);
	reader.onload = function (evt) {
		var stl = evt.target.result
	  var geo = new THREE.Geometry();

	  // The stl binary is read into a DataView for processing
    var dv = new DataView(stl, 80); // 80 == unused header
    var isLittleEndian = true;

    // Read a 32 bit unsigned integer
    var triangles = dv.getUint32(0, isLittleEndian);

    var offset = 4;
    for (var i = 0; i < triangles; i++) {
      // Get the normal for this triangle by reading 3 32 but floats
      var normal = new THREE.Vector3(
        dv.getFloat32(offset, isLittleEndian),
        dv.getFloat32(offset+4, isLittleEndian),
        dv.getFloat32(offset+8, isLittleEndian)
      );
      offset += 12;

      // Get all 3 vertices for this triangle, each represented
      // by 3 32 bit floats.
      for (var j = 0; j < 3; j++) {
        geo.vertices.push(
          new THREE.Vector3(
            dv.getFloat32(offset, isLittleEndian),
            dv.getFloat32(offset+4, isLittleEndian),
            dv.getFloat32(offset+8, isLittleEndian)
          )
        );
        offset += 12
      }

      // there's also a Uint16 "attribute byte count" that we
      // don't need, it should always be zero.
      offset += 2;

      // Create a new face for from the vertices and the normal
      geo.faces.push(new THREE.Face3(i*3, i*3+1, i*3+2, normal));
    }

	  var mat = new THREE.MeshBasicMaterial({color: 0xff0000, opacity: 0.5, transparent: true});
	  var mat2 = new THREE.MeshBasicMaterial({color: 0xffff00, wireframe: true});
	  var mesh = new THREE.Mesh(geo, mat);
	  var mesh2 = new THREE.Mesh(geo, mat2);

		scene.add(mesh);
		scene.add(mesh2);

		postProcess(geo)
	}
}


// function that fills in sidebar statistics and calculates regular faces, vertices, and lines
var postProcess = function(geometry, lines, vertices) {
	// filling in barebone information from the stl file triangles
	var faceNum = geometry.faces.length;
	$("div.triangle-face-count").html("Triangle Faces: " + faceNum);

	var vertNum = geometry.vertices.length
	$("div.triangle-vertex-count").html("Triangle Vertices: " + vertNum);

	var lineNum = 0
	for (var index in lines) {
		lineNum += 1;
	}
	$("div.triangle-line-count").html("Triangle Lines: " + lineNum);
	
	// faceConnections is an object that saves which face is connected to which face
	// faceConnections[face 1] = [face 2, face 3, ...]
	var faceConnections = {};
	
	// connecting the faces using the lines object
	for (var index in lines) {
		if (faceConnections[lines[index][0]]) {
			faceConnections[lines[index][0]].push(lines[index][1]);
		} else {
			faceConnections[lines[index][0]] = [lines[index][1]];
		}
		
		if (faceConnections[lines[index][1]]) {
			faceConnections[lines[index][1]].push(lines[index][0]);
		} else {
			faceConnections[lines[index][1]] = [lines[index][0]];
		}
	}

	// finding the number of regular faces using the faceConnection objects and face normals
	// For each face connected to the current face, if the normal is the same, then it is on the same regular face.
	// This is done until all faces and included in some regular face.
	var checked = {};
	var regFaces = [];
	
	var recursiveFaceConnect = function(index) {
		faceConnections[index].forEach(function(el) {
			if (!checked[el]) {
				var currFaceNormal = geometry.faces[el].normal;
				if (isSameVectorOrVertex(currFaceNormal, normal)) {
					face.push(el);
					checked[el] = true;

					recursiveFaceConnect(el);
				}
			}
		});
	};

	for (var index in faceConnections) {
		index = parseInt(index)
		if (!checked[index]) {
			var face = [index];
			var normal = geometry.faces[index].normal;
			checked[index] = true;
			recursiveFaceConnect(index)

			regFaces.push(face);
		}
	}

	$("div.regular-face-count").html("Regular Faces: " + regFaces.length);
	
	// finding the number of regular vertices using the vertices object
	// Vertices that only have one normal associated with it is not a regular vertex.
	// In other words, if a vertex is only connected to faces with the same normal vector, is it not a regular vertex.
	var regVertCount = 0;
	for (var index in vertices) {
		if (vertices[index].length > 1) {
			regVertCount += 1
		}
	}
	
	$("div.regular-vertex-count").html("Regular Vertices: " + regVertCount);
	
	// finding the number of regular lines using the lines object
	// Lines that connect two faces with the same normals is not a regular line
	var regLineCount = 0;
	for (var index in lines) {
		var normal1 = geometry.faces[lines[index][0]].normal;
		var normal2 = geometry.faces[lines[index][1]].normal;

		if (!isSameVectorOrVertex(normal1, normal2)) {
			regLineCount += 1;
		}
	}

	$("div.regular-line-count").html("Regular Lines: " + regLineCount);
}


// function that removes previously loaded solids
var removePreviousSolid = function () {
	for (var i = scene.children.length - 1; i >= 0; i--) {
		if (scene.children[i].type == "Mesh") {
			scene.remove(scene.children[i]);
		}
	}
}


// raycaster is used to find faces that the mouse is intersecting when the user clicks
var raycaster = new THREE.Raycaster();
var mouse = { x: 0, y: 0 }, intersected;

// When the user clicks, faces that were intersected are found.
// The color of the very first face that is intersected is changed to yellow or red.
$("canvas").on("click", function(event) {
	var sidebarWidth = $("div.sidebar").width();
	mouse.x = ( (event.clientX - sidebarWidth) / (window.innerWidth - sidebarWidth) ) * 2 - 1;
	mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

	var vector = new THREE.Vector3( mouse.x, mouse.y, 0.5 ).unproject( camera );

	raycaster.ray.set( camera.position, vector.sub( camera.position ).normalize() );

	var intersects = raycaster.intersectObjects( scene.children );

	if (intersects.length > 0) {
		if (intersected != intersects[ 0 ]) {
			intersected = intersects[ 0 ];
			var matIndex = intersected.face.materialIndex;
			if (intersected.object.material.materials[matIndex].color.g === 1) {
				intersected.object.material.materials[matIndex].color.g = 0;
			} else {
				intersected.object.material.materials[matIndex].color.g = 1;
			}
		}
	} else {
		intersected = null;
	}
});

// mouse x position used for sizing the sidebar
$(document).on("mousemove", function(event) {
	mouse.realX = event.clientX;
});

// changing the three.js renderer and camera when the window is resized or the sidebar size is changed
var threeResizer = function() {
	var sidebarWidth = $("div.sidebar").width();

	camera.aspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
	camera.updateProjectionMatrix();

	renderer.setSize( (window.innerWidth - sidebarWidth), window.innerHeight);

	$("canvas").css("left", sidebarWidth);
}

$(window).on("resize", function() {
	threeResizer();
});

// code for resizing of sidebar
$("div.sidebar div.expander").on("mousedown", function(event) {
	event.preventDefault();
	var resizing = function(event) {
		$("div.sidebar").width(mouse.realX);
		if (mouse.realX > 200) {
			$("div.sidebar div.expander").css("left", mouse.realX);
		} else {
			$("div.sidebar div.expander").css("left", 200);
		}

		threeResizer();
	};
	$(window).on("mousemove", resizing);
	
	$(window).one("mouseup", function(event) {
		$(window).off("mousemove", resizing);
	});
});

// checks if two vectors or vertices are the same by checking with 0.0001 accuracy
var isSameVectorOrVertex = function (vector1, vector2) {
	var condx = Math.abs(vector1.x - vector2.x) < 0.0001;
	var condy = Math.abs(vector1.y - vector2.y) < 0.0001;
	var condz = Math.abs(vector1.z - vector2.z) < 0.0001;
	
	return condx && condy && condz;
}

</script>

</html>
