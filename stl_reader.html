<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>STL Reader</title>
	<style>
		body { 
			margin: 0;
			padding: 0;
			border: 0;
			font-family: sans-serif;
			font-size: 15px;
		}

		div.sidebar { 
			position: fixed;
			top: 0;
			bottom: 0;
			left: 0;
			width: 200px;
			background: lightgrey;
			z-index: 1;
			min-width: 200px;
		}

		div.sidebar input[type="file"] { 
			float: left;
			-webkit-box-sizing: border-box;
			-moz-box-sizing: border-box;
			box-sizing: border-box;
			width: 100%;
			border-bottom: 1px solid grey;
			padding: 3px;
		}

		div.sidebar div {
			-webkit-box-sizing: border-box;
			-moz-box-sizing: border-box;
			box-sizing: border-box;
			width: 100%;
			float: left;
			padding: 5px;
		}

		div.sidebar div.divider {
			width: 100%;
			height: 1px;
			padding: 0;
			background: grey;
		}

		div.sidebar div.expander {
			position: fixed;
			left: 200px;
			height: 100%;
			width: 5px;
			background: lightgrey;
			border-right: 1px solid grey;
			border-left: 2px solid grey;
			padding: 0;
			cursor: col-resize;
		}

		canvas {
			position: fixed;
			top: 0;
			left: 200px;
		}
	</style>
</head>
<script src="jquery-1.11.1.min.js"></script>
<script src="three.min.js"></script>
<script src="OrbitControls.js"></script>
<body>
	<div class="sidebar">
		<div class="expander"></div>
		<input type="file" id="stl_input" onchange="handleStlFile(this.files)">
		<div class="triangle-face-count">Triangle Faces: --</div>
		<div class="triangle-vertex-count">Triangle Vertices: --</div>
		<div class="triangle-line-count">Triangle Lines: --</div>
		<div class="divider"></div>
		<div class="regular-face-count">Regular Faces: --</div>
		<div class="regular-vertex-count">Regular Vertices: --</div>
		<div class="regular-line-count">Regular Lines: --</div>
	</div>
</body>

<script>
var scene = new THREE.Scene();
var camera = new THREE.PerspectiveCamera( 75, (window.innerWidth - 200) / window.innerHeight, 0.1, 1000 );

var renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize( window.innerWidth - 200, window.innerHeight );
document.body.appendChild( renderer.domElement );

camera.position.set( -40, -40, 10 );

cameraControls = new THREE.OrbitControls(camera, renderer.domElement);
cameraControls.target.set( 0, 0, 0);
cameraControls.update();

// var ambientLight = new THREE.AmbientLight(0x330000);
//  scene.add(ambientLight);

// var pointLight = new THREE.PointLight(0xffffff);
// pointLight.position.set( 100, 100, 100 );
// scene.add( pointLight );

// var directionalLight = new THREE.DirectionalLight(0xffffff);
//  directionalLight.position.set(1, 1, 1).normalize();
//  scene.add(directionalLight);

var raycaster = new THREE.Raycaster();

var mouse = { x: 0, y: 0 }, INTERSECTED;

$(document).on("mousemove", function(event) {
	mouse.realX = event.clientX;
});

function render() {
	renderer.render( scene, camera );
	requestAnimationFrame( render );
	cameraControls.update();
}

render();


function handleStlFile(files) {
	file = files[0]
	if (file) {
		var reader = new FileReader();
		reader.readAsText(file, "UTF-8");
		reader.onload = function (evt) {
			if (evt.target.result.substr(0,5) === "solid") {
				for (var i = scene.children.length - 1; i >= 0; i--) {
					if (scene.children[i].type == "Mesh") {
						scene.remove(scene.children[i]);
					}
				}

				var vertRegex = /(vertex\s-?[\d\.]+\s-?[\d\.]+\s-?[\d\.]+)/g;
				var vertMatches = evt.target.result.match(vertRegex);

				var normRegex = /(facet\snormal\s-?[\d\.]+\s-?[\d\.]+\s-?[\d\.]+)/g;
				var normMatches = evt.target.result.match(normRegex);

				var geometry = new THREE.Geometry();
				var geomMats = new Array(vertMatches.length);

				var lines = {}
				var vertices = {}

				var addFaceToLine = function(lines, line, currFace) {
					if (lines[line]) {
						lines[line].push(currFace);
					} else {
						lines[line] = [currFace];
					}
				};

				var lineHandle = function(lines, currFace, v1Index, v2Index, v3Index) {
					var line = [v1Index,v2Index].sort();
					addFaceToLine(lines, line, currFace);

					var line = [v2Index,v3Index].sort();
					addFaceToLine(lines, line, currFace);

					var line = [v1Index,v3Index].sort();
					addFaceToLine(lines, line, currFace);
				};

				var vertexHandle = function(split, geometry) {
					var vertIndex = -1;

					var vert = new THREE.Vector3(parseFloat(split[1]),parseFloat(split[2]),parseFloat(split[3]));
					geometry.vertices.forEach(function(vertex, index) {
						if (Math.abs(vert.x - vertex.x) < 0.0001 && Math.abs(vert.y - vertex.y) < 0.0001 && Math.abs(vert.z - vertex.z) < 0.0001) {
							vertIndex = index + 1;

							return false;
						}
					});

					if (vertIndex === -1) {
						vertIndex = geometry.vertices.push(vert);
					}

					return [vert, vertIndex];
				};

				for (var i = 0; i < vertMatches.length; i++) {
					geomMats[i] = new THREE.MeshBasicMaterial({color: 0xff0000, opacity: 0.5, transparent: true});
					split = vertMatches[i].split(" ")

					var v1, v2, v3, v1Index, v2Index, v3Index;
					if (i % 3 == 0) {
						var result = vertexHandle(split, geometry);
						v1 = result[0];
						v1Index = result[1];
					} else if (i % 3 == 1) {
						var result = vertexHandle(split, geometry);
						v2 = result[0];
						v2Index = result[1];
					} else if (i % 3 == 2) {
						var result = vertexHandle(split, geometry);
						v3 = result[0];
						v3Index = result[1];

						normSplit = normMatches[Math.floor(i/3)].split(" ");
						normal = new THREE.Vector3(parseFloat(normSplit[2]),parseFloat(normSplit[3]),parseFloat(normSplit[4]));

            // var face1 = new THREE.Face3(geometry.vertices.length-2,geometry.vertices.length-3,geometry.vertices.length-1);
            // face1.materialIndex = i;
            var face2 = new THREE.Face3(v1Index - 1, v2Index - 1, v3Index - 1, normal);
            face2.materialIndex = i;
						// geometry.faces.push(face1);
						var currFace = geometry.faces.push(face2);
						currFace -= 1;

						lineHandle(lines, currFace, v1Index, v2Index, v3Index);

						var currFaceNormal = geometry.faces[geometry.faces.length - 1].normal
						if (vertices[v1Index]) {
							if (vertices[v1Index].length < 2) {
								if (!(Math.abs(vertices[v1Index][0].x - currFaceNormal.x) < 0.0001 && Math.abs(vertices[v1Index][0].y - currFaceNormal.y) < 0.0001 && Math.abs(vertices[v1Index][0].z - currFaceNormal.z) < 0.0001)) {
									vertices[v1Index].push(currFaceNormal);
								}
							}
						} else {
							vertices[v1Index] = [currFaceNormal];
						}

						if (vertices[v2Index]) {
							if (vertices[v2Index].length < 2) {
								if (!(Math.abs(vertices[v2Index][0].x - currFaceNormal.x) < 0.0001 && Math.abs(vertices[v2Index][0].y - currFaceNormal.y) < 0.0001 && Math.abs(vertices[v2Index][0].z - currFaceNormal.z) < 0.0001)) {
									vertices[v2Index].push(currFaceNormal);
								}
							}
						} else {
							vertices[v2Index] = [currFaceNormal];
						}

						if (vertices[v3Index]) {
							if (vertices[v3Index].length < 2) {
								if (!(Math.abs(vertices[v3Index][0].x - currFaceNormal.x) < 0.0001 && Math.abs(vertices[v3Index][0].y - currFaceNormal.y) < 0.0001 && Math.abs(vertices[v3Index][0].z - currFaceNormal.z) < 0.0001)) {
									vertices[v3Index].push(currFaceNormal);
								}
							}
						} else {
							vertices[v3Index] = [currFaceNormal];
						}
					}
				}

				var wireframe = new THREE.MeshBasicMaterial({color: 0xffff00, wireframe: true});
				var triangle = new THREE.Mesh(geometry, new THREE.MeshFaceMaterial(geomMats));
				var triangle2 = new THREE.Mesh(geometry, wireframe);

				scene.add(triangle)
				scene.add(triangle2)

				postProcess(geometry, lines, vertices)
			} else {
				for (var i = scene.children.length - 1; i >= 0; i--) {
					if (scene.children[i].type == "Mesh") {
						scene.remove(scene.children[i]);
					}
				}
				var reader = new FileReader();
				reader.readAsArrayBuffer(file);
				reader.onload = function (evt) {
					handleStlBinary(evt.target.result)
				}

				// "stl" represents a raw STL binary read from HTTP response data
				var handleStlBinary = function(stl) {
				  // create three.js geometry object, discussed later
				  var geo = new THREE.Geometry();

				  // The stl binary is read into a DataView for processing
			    var dv = new DataView(stl, 80); // 80 == unused header
			    var isLittleEndian = true;

			    // Read a 32 bit unsigned integer
			    var triangles = dv.getUint32(0, isLittleEndian);

			    var offset = 4;
			    for (var i = 0; i < triangles; i++) {
		        // Get the normal for this triangle by reading 3 32 but floats
		        var normal = new THREE.Vector3(
		          dv.getFloat32(offset, isLittleEndian),
		          dv.getFloat32(offset+4, isLittleEndian),
		          dv.getFloat32(offset+8, isLittleEndian)
		        );
		        offset += 12;

		        // Get all 3 vertices for this triangle, each represented
		        // by 3 32 bit floats.
		        for (var j = 0; j < 3; j++) {
	            geo.vertices.push(
                new THREE.Vector3(
                  dv.getFloat32(offset, isLittleEndian),
                  dv.getFloat32(offset+4, isLittleEndian),
                  dv.getFloat32(offset+8, isLittleEndian)
                )
	            );
	            offset += 12
		        }

		        // there's also a Uint16 "attribute byte count" that we
		        // don't need, it should always be zero.
		        offset += 2;

		        // Create a new face for from the vertices and the normal
		        geo.faces.push(new THREE.Face3(i*3, i*3+1, i*3+2, normal));
			    }

				  var mat = new THREE.MeshBasicMaterial({color: 0xff0000, opacity: 0.5, transparent: true});
				  var mat2 = new THREE.MeshBasicMaterial({color: 0xffff00, wireframe: true});
				  var mesh = new THREE.Mesh(geo, mat);
				  var mesh2 = new THREE.Mesh(geo, mat2);

					scene.add(mesh);
					scene.add(mesh2);

					postProcess(geo)
				};
			}
		}

		reader.onerror = function (evt) {
			$("div.disp-stl").html("error reading file");
		}
	}
}

var postProcess = function(geometry, lines, vertices) {
	var faceNum = geometry.faces.length;
	$("div.triangle-face-count").html("Triangle Faces: " + faceNum);

	var vertNum = geometry.vertices.length
	$("div.triangle-vertex-count").html("Triangle Vertices: " + vertNum);

	var lineNum = 0
	for (var index in lines) {
		lineNum += 1;
	}
	$("div.triangle-line-count").html("Triangle Lines: " + lineNum);

	var faceConnections = {};
	for (var index in lines) {
		if (faceConnections[lines[index][0]]) {
			faceConnections[lines[index][0]].push(lines[index][1]);
		} else {
			faceConnections[lines[index][0]] = [lines[index][1]];
		}
		
		if (faceConnections[lines[index][1]]) {
			faceConnections[lines[index][1]].push(lines[index][0]);
		} else {
			faceConnections[lines[index][1]] = [lines[index][0]];
		}
	}

	var checked = {};
	var regFaces = [];

	var recursiveFaceConnect = function(index) {
		faceConnections[index].forEach(function(el) {
			if (!checked[el]) {
				var currFaceNormal = geometry.faces[el].normal;
				if (Math.abs(currFaceNormal.x-normal.x) < 0.0001 && Math.abs(currFaceNormal.y-normal.y) < 0.0001 && Math.abs(currFaceNormal.z-normal.z) < 0.0001) {
					face.push(el);
					checked[el] = true;

					recursiveFaceConnect(el);
				}
			}
		});
	};

	for (var index in faceConnections) {
		index = parseInt(index)
		if (!checked[index]) {
			var face = [index];
			var normal = geometry.faces[index].normal;
			checked[index] = true;
			recursiveFaceConnect(index)

			regFaces.push(face);
		}
	}

	$("div.regular-face-count").html("Regular Faces: " + regFaces.length);

	var regVertCount = 0;
	for (var index in vertices) {
		if (vertices[index].length > 1) {
			regVertCount += 1
		}
	}
	$("div.regular-vertex-count").html("Regular Vertices: " + regVertCount);

	var regLineCount = 0;
	for (var index in lines) {
		console.log(lines[index])
		var normal1 = geometry.faces[lines[index][0]].normal;
		var normal2 = geometry.faces[lines[index][1]].normal;

		if (!(Math.abs(normal1.x - normal2.x) < 0.0001 && Math.abs(normal1.y - normal2.y) < 0.0001 && Math.abs(normal1.z - normal2.z) < 0.0001)) {
			regLineCount += 1;
		}
	}

	$("div.regular-line-count").html("Regular Lines: " + regLineCount);


	$("canvas").on("click", function(event) {
		var sidebarWidth = $("div.sidebar").width();
		mouse.x = ( (event.clientX - sidebarWidth) / (window.innerWidth - sidebarWidth) ) * 2 - 1;
		mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

		var vector = new THREE.Vector3( mouse.x, mouse.y, 0.5 ).unproject( camera );

		raycaster.ray.set( camera.position, vector.sub( camera.position ).normalize() );

		var intersects = raycaster.intersectObjects( scene.children );

		if ( intersects.length > 0 ) {
			if ( INTERSECTED != intersects[ 0 ] ) {
				INTERSECTED = intersects[ 0 ];
				var matIndex = INTERSECTED.face.materialIndex;
				console.log(INTERSECTED)
				if (INTERSECTED.object.material.materials[matIndex].color.g === 1) {
					INTERSECTED.object.material.materials[matIndex].color.g = 0;
				} else {
					INTERSECTED.object.material.materials[matIndex].color.g = 1;
				}
			}
		} else {
			INTERSECTED = null;
		}
	});
}

var threeResizer = function() {
	var sidebarWidth = $("div.sidebar").width();

	camera.aspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
	camera.updateProjectionMatrix();

	renderer.setSize( (window.innerWidth - sidebarWidth), window.innerHeight);

	$("canvas").css("left", sidebarWidth);
}

$(window).on("resize", function() {
	threeResizer();
});

$("div.sidebar div.expander").on("mousedown", function(event) {
	event.preventDefault();
	var resizing = function(event) {
		$("div.sidebar").width(mouse.realX);
		if (mouse.realX > 200) {
			$("div.sidebar div.expander").css("left", mouse.realX);
		} else {
			$("div.sidebar div.expander").css("left", 200);
		}

		threeResizer();
	};
	$(window).on("mousemove", resizing);
	
	$(window).one("mouseup", function(event) {
		$(window).off("mousemove", resizing);
	});
});

</script>

</html>
