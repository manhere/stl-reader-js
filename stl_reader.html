<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>STL Reader</title>
	<style>
		body { 
			margin: 0;
			padding: 0;
			border: 0;
			font-family: sans-serif;
			font-size: 15px;
		}

		div.sidebar { 
			position: fixed;
			top: 0;
			bottom: 0;
			left: 0;
			width: 200px;
			background: lightgrey;
			z-index: 1;
		}

		div.sidebar input[type="file"] { 
			float: left;
			-webkit-box-sizing: border-box;
			-moz-box-sizing: border-box;
			box-sizing: border-box;
			width: 100%;
			border-bottom: 1px solid grey;
			padding: 3px;
		}

		div.sidebar div {
			-webkit-box-sizing: border-box;
			-moz-box-sizing: border-box;
			box-sizing: border-box;
			width: 100%;
			float: left;
			padding: 5px;
		}

		div.sidebar input[type="file"]:focus {
			background: yellow;
		}

		canvas {
			position: fixed;
			top: 0;
			left: 200px;
		}
	</style>
</head>
<script src="jquery-1.11.1.min.js"></script>
<script src="three.min.js"></script>
<script src="OrbitControls.js"></script>
<body>
	<div class="sidebar">
		<input type="file" id="stl_input" onchange="handleStlFile(this.files)">
		<div class="triangle-face-count"></div>
		<div class="triangle-vertex-count"></div>
		<div class="triangle-line-count"></div>
		<div class="regular-face-count"></div>
	</div>
</body>

<script>
var scene = new THREE.Scene();
var camera = new THREE.PerspectiveCamera( 75, (window.innerWidth - 200) / window.innerHeight, 0.1, 1000 );

console.log(camera)

var renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize( window.innerWidth - 200, window.innerHeight );
document.body.appendChild( renderer.domElement );

camera.position.set( -40, -40, 10 );

cameraControls = new THREE.OrbitControls(camera, renderer.domElement);
cameraControls.target.set( 0, 0, 0);
cameraControls.update();

// var ambientLight = new THREE.AmbientLight(0x330000);
//  scene.add(ambientLight);

// var pointLight = new THREE.PointLight(0xffffff);
// pointLight.position.set( 100, 100, 100 );
// scene.add( pointLight );

// var directionalLight = new THREE.DirectionalLight(0xffffff);
//  directionalLight.position.set(1, 1, 1).normalize();
//  scene.add(directionalLight);

var raycaster = new THREE.Raycaster();

var mouse = { x: 0, y: 0 }, INTERSECTED;

$(document).on("click", function(event) {
	mouse.x = ( (event.clientX - 200) / (window.innerWidth - 200) ) * 2 - 1;
	mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

	var vector = new THREE.Vector3( mouse.x, mouse.y, 0.5 ).unproject( camera );

	raycaster.ray.set( camera.position, vector.sub( camera.position ).normalize() );

	var intersects = raycaster.intersectObjects( scene.children );

	if ( intersects.length > 0 ) {
		if ( INTERSECTED != intersects[ 0 ] ) {
			INTERSECTED = intersects[ 0 ];
			var matIndex = INTERSECTED.face.materialIndex;
			if (INTERSECTED.object.material.materials[matIndex].color.g === 1) {
				INTERSECTED.object.material.materials[matIndex].color.g = 0;
			} else {
				INTERSECTED.object.material.materials[matIndex].color.g = 1;
			}
      console.log(INTERSECTED)
		  console.log(INTERSECTED.face.color.materialIndex)
		}
	} else {
		INTERSECTED = null;
	}
});

function render() {
	renderer.render( scene, camera );
	requestAnimationFrame( render );
	cameraControls.update();
}

render();

$(window).on("resize", function() {
	camera.aspect = (window.innerWidth - 200) / window.innerHeight;
	camera.updateProjectionMatrix();

	renderer.setSize( (window.innerWidth - 200), window.innerHeight );

});


function handleStlFile(files) {
	file = files[0]
	if (file) {
		var reader = new FileReader();
		reader.readAsText(file, "UTF-8");
		reader.onload = function (evt) {
			if (evt.target.result.substr(0,5) === "solid") {
				for (var i = scene.children.length - 1; i >= 0; i--) {
					if (scene.children[i].type == "Mesh") {
						scene.remove(scene.children[i]);
					}
				}

				var vertRegex = /(vertex\s-?[\d\.]+\s-?[\d\.]+\s-?[\d\.]+)/g;
				var vertMatches = evt.target.result.match(vertRegex);

				var normRegex = /(facet\snormal\s-?[\d\.]+\s-?[\d\.]+\s-?[\d\.]+)/g;
				var normMatches = evt.target.result.match(normRegex);

				var geometry = new THREE.Geometry();
				var geomMats = new Array(vertMatches.length);

				var lines = {}

				for (var i = 0; i < vertMatches.length; i++) {
					geomMats[i] = new THREE.MeshBasicMaterial({color: 0xff0000, opacity: 0.5, transparent: true});
					split = vertMatches[i].split(" ")

					var v1, v2, v3, v1Index, v2Index, v3Index;
					if (i % 3 == 0) {
						v1Index = -1;

						v1 = new THREE.Vector3(parseFloat(split[1]),parseFloat(split[2]),parseFloat(split[3]));
						geometry.vertices.forEach(function(vertex, index) {
							if (Math.abs(v1.x - vertex.x) < 0.0001 && Math.abs(v1.y - vertex.y) < 0.0001 && Math.abs(v1.z - vertex.z) < 0.0001) {
								v1Index = index + 1;

								return false;
							}
						});

						if (v1Index === -1) {
							v1Index = geometry.vertices.push(v1);
						}
					} else if (i % 3 == 1) {
						v2Index = -1;

						v2 = new THREE.Vector3(parseFloat(split[1]),parseFloat(split[2]),parseFloat(split[3]));
						geometry.vertices.forEach(function(vertex, index) {
							if (Math.abs(v2.x - vertex.x) < 0.0001 && Math.abs(v2.y - vertex.y) < 0.0001 && Math.abs(v2.z - vertex.z) < 0.0001) {
								v2Index = index + 1;

								return false;
							}
						});

						if (v2Index === -1) {
							v2Index = geometry.vertices.push(v2);
						}
					} else if (i % 3 == 2) {
						v3Index = -1;
						v3 = new THREE.Vector3(parseFloat(split[1]),parseFloat(split[2]),parseFloat(split[3]));
						geometry.vertices.forEach(function(vertex, index) {
							if (Math.abs(v3.x - vertex.x) < 0.0001 && Math.abs(v3.y - vertex.y) < 0.0001 && Math.abs(v3.z - vertex.z) < 0.0001) {
								v3Index = index + 1;

								return false
							}
						});

						if (v3Index === -1) {
							v3Index = geometry.vertices.push(v3);
						}

						normSplit = normMatches[Math.floor(i/3)].split(" ");
						normal = new THREE.Vector3(parseFloat(normSplit[2]),parseFloat(normSplit[3]),parseFloat(normSplit[4]));

            // var face1 = new THREE.Face3(geometry.vertices.length-2,geometry.vertices.length-3,geometry.vertices.length-1);
            // face1.materialIndex = i;
            var face2 = new THREE.Face3(v1Index - 1, v2Index - 1, v3Index - 1, normal);
            face2.materialIndex = i;
						// geometry.faces.push(face1);
						var currFace = geometry.faces.push(face2);
						currFace -= 1;

						var line = [v1Index,v2Index].sort();
						if (lines[line]) {
							lines[line].push(currFace);
						} else {
							lines[line] = [currFace];
						}

						var line = [v2Index,v3Index].sort();
						if (lines[line]) {
							lines[line].push(currFace);
						} else {
							lines[line] = [currFace];
						}

						var line = [v1Index,v3Index].sort();
						if (lines[line]) {
							lines[line].push(currFace);
						} else {
							lines[line] = [currFace];
						}
					}
				}

				var wireframe = new THREE.MeshBasicMaterial({color: 0xffff00, wireframe: true});
				var triangle = new THREE.Mesh(geometry, new THREE.MeshFaceMaterial(geomMats));
				var triangle2 = new THREE.Mesh(geometry, wireframe);

				scene.add(triangle)
				scene.add(triangle2)

				postProcess(geometry, lines)
			} else {
				for (var i = scene.children.length - 1; i >= 0; i--) {
					if (scene.children[i].type == "Mesh") {
						scene.remove(scene.children[i]);
					}
				}
				var reader = new FileReader();
				reader.readAsArrayBuffer(file);
				reader.onload = function (evt) {
					handleStlBinary(evt.target.result)
				}

				// "stl" represents a raw STL binary read from HTTP response data
				var handleStlBinary = function(stl) {
				  // create three.js geometry object, discussed later
				  var geo = new THREE.Geometry();

				  // The stl binary is read into a DataView for processing
			    var dv = new DataView(stl, 80); // 80 == unused header
			    var isLittleEndian = true;

			    // Read a 32 bit unsigned integer
			    var triangles = dv.getUint32(0, isLittleEndian);

			    var offset = 4;
			    for (var i = 0; i < triangles; i++) {
		        // Get the normal for this triangle by reading 3 32 but floats
		        var normal = new THREE.Vector3(
		          dv.getFloat32(offset, isLittleEndian),
		          dv.getFloat32(offset+4, isLittleEndian),
		          dv.getFloat32(offset+8, isLittleEndian)
		        );
		        offset += 12;

		        // Get all 3 vertices for this triangle, each represented
		        // by 3 32 bit floats.
		        for (var j = 0; j < 3; j++) {
	            geo.vertices.push(
                new THREE.Vector3(
                  dv.getFloat32(offset, isLittleEndian),
                  dv.getFloat32(offset+4, isLittleEndian),
                  dv.getFloat32(offset+8, isLittleEndian)
                )
	            );
	            offset += 12
		        }

		        // there's also a Uint16 "attribute byte count" that we
		        // don't need, it should always be zero.
		        offset += 2;

		        // Create a new face for from the vertices and the normal
		        geo.faces.push(new THREE.Face3(i*3, i*3+1, i*3+2, normal));
			    }

				  var mat = new THREE.MeshBasicMaterial({color: 0xff0000, opacity: 0.5, transparent: true});
				  var mat2 = new THREE.MeshBasicMaterial({color: 0xffff00, wireframe: true});
				  var mesh = new THREE.Mesh(geo, mat);
				  var mesh2 = new THREE.Mesh(geo, mat2);

					scene.add(mesh);
					scene.add(mesh2);

					postProcess(geo)
				};
			}
		}

		reader.onerror = function (evt) {
			$("div.disp-stl").html("error reading file");
		}
	}
}

var postProcess = function(geometry, lines) {
	var faceNum = geometry.faces.length;
	$("div.triangle-face-count").html("Triangle Faces: " + faceNum);

	var vertNum = geometry.vertices.length
	$("div.triangle-vertex-count").html("Triangle Vertices: " + vertNum);

	var lineNum = 0
	for (var index in lines) {
		lineNum += 1;
	}
	$("div.triangle-line-count").html("Triangle Lines: " + lineNum);

	var faceConnections = {};
	for (var index in lines) {
		if (faceConnections[lines[index][0]]) {
			faceConnections[lines[index][0]].push(lines[index][1]);
		} else {
			faceConnections[lines[index][0]] = [lines[index][1]];
		}
		
		if (faceConnections[lines[index][1]]) {
			faceConnections[lines[index][1]].push(lines[index][0]);
		} else {
			faceConnections[lines[index][1]] = [lines[index][0]];
		}
	}

	var checked = {};
	var regFaces = [];

	var recursiveFaceConnect = function(index) {
		faceConnections[index].forEach(function(el) {
			if (!checked[el]) {
				var currFaceNormal = geometry.faces[el].normal;
				if (Math.abs(currFaceNormal.x-normal.x) < 0.0001 && Math.abs(currFaceNormal.y-normal.y) < 0.0001 && Math.abs(currFaceNormal.z-normal.z) < 0.0001) {
					face.push(el);
					checked[el] = true;

					recursiveFaceConnect(el);
				}
			}
		});
	};

	for (var index in faceConnections) {
		index = parseInt(index)
		if (!checked[index]) {
			var face = [index];
			var normal = geometry.faces[index].normal;
			checked[index] = true;
			recursiveFaceConnect(index)

			regFaces.push(face);
		}
	}

	$("div.regular-face-count").html("Regular Faces: " + regFaces.length);
	console.log(geometry)
}

</script>

</html>
