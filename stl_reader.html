<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>STL Reader</title>
	<style>
		body { margin: 0; overflow: hidden }
		input[type="file"] { position: fixed; top: 0; left: 0; float: left; z-index: 2 }
		canvas { position: fixed; top: 0; left: 0 }
	</style>
</head>
<script src="jquery-1.11.1.min.js"></script>
<script src="three.min.js"></script>
<script src="OrbitControls.js"></script>
<body>
	<input type="file" id="stl_input" onchange="handleStlFile(this.files)">
	<div class="disp-stl"></div>
</body>

<script>
var scene = new THREE.Scene();
var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );

var renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize( window.innerWidth, window.innerHeight );
document.body.appendChild( renderer.domElement );

camera.position.set( -40, -40, 10 );

cameraControls = new THREE.OrbitControls(camera, renderer.domElement);
cameraControls.target.set( 0, 0, 0);
cameraControls.maxDistance = 400;
cameraControls.minDistance = 10;
cameraControls.update();

// var ambientLight = new THREE.AmbientLight(0x330000);
//  scene.add(ambientLight);

// var pointLight = new THREE.PointLight(0xffffff);
// pointLight.position.set( 100, 100, 100 );
// scene.add( pointLight );

// var directionalLight = new THREE.DirectionalLight(0xffffff);
//  directionalLight.position.set(1, 1, 1).normalize();
//  scene.add(directionalLight);

var raycaster = new THREE.Raycaster();

var mouse = { x: 0, y: 0 }, INTERSECTED;

$(document).on("click", function(event) {
	mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
	mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

	var vector = new THREE.Vector3( mouse.x, mouse.y, 0.5 ).unproject( camera );

	raycaster.ray.set( camera.position, vector.sub( camera.position ).normalize() );

	var intersects = raycaster.intersectObjects( scene.children );

	if ( intersects.length > 0 ) {
		if ( INTERSECTED != intersects[ 0 ] ) {
			INTERSECTED = intersects[ 0 ];
			var matIndex = INTERSECTED.face.materialIndex;
			if (INTERSECTED.object.material.materials[matIndex].color.g === 1) {
				INTERSECTED.object.material.materials[matIndex].color.g = 0;
			} else {
				INTERSECTED.object.material.materials[matIndex].color.g = 1;
			}
      console.log(INTERSECTED)
		  console.log(INTERSECTED.face.color.materialIndex)
		}
	} else {
		INTERSECTED = null;
	}
})

function render() {
	renderer.render( scene, camera );
	requestAnimationFrame( render );
	cameraControls.update();
}

render();



function handleStlFile(files) {
	file = files[0]
	if (file) {
		var reader = new FileReader();
		reader.readAsText(file, "UTF-8");
		reader.onload = function (evt) {
			if (evt.target.result.substr(0,5) === "solid") {
				for (var i = scene.children.length - 1; i >= 0; i--) {
					if (scene.children[i].type == "Mesh") {
						scene.remove(scene.children[i]);
					}
				}

				var regex = /(vertex\s-?[\d\.]+\s-?[\d\.]+\s-?[\d\.]+)/g;
				var matches = evt.target.result.match(regex);
				console.log(evt.target.result)
				var geometry = new THREE.Geometry();
				var geomMats = new Array(matches.length);

				for (var i = 0; i < matches.length; i++) {
					geomMats[i] = new THREE.MeshBasicMaterial({color: 0xff0000, opacity: 0.5, transparent: true});
					split = matches[i].split(" ")

					var v1, v2, v3;
					if (i % 3 == 0) {
						v1 = new THREE.Vector3(parseFloat(split[1]),parseFloat(split[2]),parseFloat(split[3]));
						geometry.vertices.push(v1);
					} else if (i % 3 == 1) {
						v2 = new THREE.Vector3(parseFloat(split[1]),parseFloat(split[2]),parseFloat(split[3]));
						geometry.vertices.push(v2);
					} else if (i % 3 == 2) {
						v3 = new THREE.Vector3(parseFloat(split[1]),parseFloat(split[2]),parseFloat(split[3]));
						geometry.vertices.push(v3);
            // var face1 = new THREE.Face3(geometry.vertices.length-2,geometry.vertices.length-3,geometry.vertices.length-1);
            // face1.materialIndex = i;
            var face2 = new THREE.Face3(geometry.vertices.length-3,geometry.vertices.length-2,geometry.vertices.length-1);
            face2.materialIndex = i;
						// geometry.faces.push(face1);
						geometry.faces.push(face2);
					}
				}

				var wireframe = new THREE.MeshBasicMaterial({color: 0xffff00, wireframe: true});
				var triangle = new THREE.Mesh(geometry, new THREE.MeshFaceMaterial(geomMats));
				var triangle2 = new THREE.Mesh(geometry, wireframe);

				scene.add(triangle)
				scene.add(triangle2)
			} else {
				for (var i = scene.children.length - 1; i >= 0; i--) {
					if (scene.children[i].type == "Mesh") {
						scene.remove(scene.children[i]);
					}
				}
				console.log(file)
				var reader = new FileReader();
				reader.readAsArrayBuffer(file);
				reader.onload = function (evt) {
					console.log(evt)
					parseStlBinary(evt.target.result)
				}

				// "stl" represents a raw STL binary read from HTTP response data
				var parseStlBinary = function(stl) {
				  // create three.js geometry object, discussed later
				  var geo = new THREE.Geometry();

				  // The stl binary is read into a DataView for processing
			    var dv = new DataView(stl, 80); // 80 == unused header
			    console.log(dv)
			    var isLittleEndian = true;

			    // Read a 32 bit unsigned integer
			    var triangles = dv.getUint32(0, isLittleEndian);

			    var offset = 4;
			    for (var i = 0; i < triangles; i++) {
		        // Get the normal for this triangle by reading 3 32 but floats
		        var normal = new THREE.Vector3(
		            dv.getFloat32(offset, isLittleEndian),
		            dv.getFloat32(offset+4, isLittleEndian),
		            dv.getFloat32(offset+8, isLittleEndian)
		        );
		        offset += 12;

		        // Get all 3 vertices for this triangle, each represented
		        // by 3 32 bit floats.
		        for (var j = 0; j < 3; j++) {
	            geo.vertices.push(
                new THREE.Vector3(
                  dv.getFloat32(offset, isLittleEndian),
                  dv.getFloat32(offset+4, isLittleEndian),
                  dv.getFloat32(offset+8, isLittleEndian)
                )
	            );
	            offset += 12
		        }

		        // there's also a Uint16 "attribute byte count" that we
		        // don't need, it should always be zero.
		        offset += 2;

		        // Create a new face for from the vertices and the normal
		        geo.faces.push(new THREE.Face3(i*3, i*3+1, i*3+2, normal));
			    }

				  // continue parsing STL faces for rendering...
				  var mat = new THREE.MeshBasicMaterial({color: 0xff0000, opacity: 0.5, transparent: true});
				  var mat2 = new THREE.MeshBasicMaterial({color: 0xffff00, wireframe: true});
				  var mesh = new THREE.Mesh(geo, mat);
				  var mesh2 = new THREE.Mesh(geo, mat2);

					scene.add(mesh);
					scene.add(mesh2);
				};
			}
		}

		reader.onerror = function (evt) {
			$("div.disp-stl").html("error reading file");
		}
	}
}

</script>

</html>
